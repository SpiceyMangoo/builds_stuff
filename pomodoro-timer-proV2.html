<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Timer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #ffffff;
            color: #37352f;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .timer-container {
            background: #ffffff;
            border: 1px solid #e9e9e7;
            border-radius: 12px;
            padding: 48px;
            max-width: 480px;
            width: 100%;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            text-align: center;
        }
        .timer-display {
            font-size: 4.5rem;
            font-weight: 600;
            color: #2c2c2c;
            margin: 32px 0;
            font-variant-numeric: tabular-nums;
            letter-spacing: -0.02em;
        }
        .pulse { 
            animation: pulse 1.5s ease-in-out infinite; 
        }
        @keyframes pulse { 
            0%, 100% { opacity: 1; } 
            50% { opacity: 0.4; } 
        }
        .session-type {
            font-size: 14px;
            font-weight: 500;
            color: #6b6b6b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        .progress-container {
            width: 100%;
            height: 4px;
            background: #f1f1ef;
            border-radius: 2px;
            margin: 24px 0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #2c2c2c;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        .input-section {
            margin: 32px 0;
        }
        .input-group {
            margin: 16px 0;
            text-align: left;
        }
        .input-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #37352f;
            margin-bottom: 6px;
        }
        input, select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #e9e9e7;
            border-radius: 6px;
            font-size: 16px;
            background: #ffffff;
            color: #37352f;
            transition: border-color 0.2s ease;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #2c2c2c;
            box-shadow: 0 0 0 2px rgba(44, 44, 44, 0.1);
        }
        input::placeholder {
            color: #a8a8a8;
        }
        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 32px 0 24px 0;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 80px;
        }
        .btn-primary {
            background: #2c2c2c;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background: #1a1a1a;
        }
        .btn-secondary {
            background: #f1f1ef;
            color: #37352f;
            border: 1px solid #e9e9e7;
        }
        .btn-secondary:hover:not(:disabled) {
            background: #e9e9e7;
        }
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .config-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #6b6b6b;
            padding: 8px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }
        .config-toggle:hover {
            background: #f1f1ef;
        }
        .config-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: #ffffff;
            border-left: 1px solid #e9e9e7;
            padding: 32px 24px;
            transition: right 0.3s ease;
            overflow-y: auto;
            z-index: 1000;
        }
        .config-panel.open {
            right: 0;
        }
        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
        }
        .config-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c2c2c;
        }
        .close-config {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6b6b6b;
            padding: 4px;
        }
        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            margin: 8px 0;
        }
        .status-connected {
            background: #e8f5e8;
            color: #2d7d2d;
        }
        .status-disconnected {
            background: #fff2f0;
            color: #d93025;
        }
        .status-connecting {
            background: #fff4e6;
            color: #e8710a;
        }
        .notification {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 16px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            z-index: 2000;
            max-width: 320px;
        }
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .notification.success { background: #2d7d2d; }
        .notification.error { background: #d93025; }
        .notification.info { background: #1a73e8; }
        .hidden { display: none !important; }
        .session-info {
            background: #f8f8f7;
            border: 1px solid #e9e9e7;
            border-radius: 8px;
            padding: 20px;
            margin: 24px 0;
            text-align: left;
        }
        .session-detail {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        .session-detail-label {
            color: #6b6b6b;
        }
        .session-detail-value {
            color: #2c2c2c;
            font-weight: 500;
        }
        .template-description {
            font-size: 13px;
            color: #6b6b6b;
            margin-top: 6px;
            line-height: 1.4;
        }
        .field-mapping {
            background: #f8f8f7;
            border: 1px solid #e9e9e7;
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
        }
        .field-mapping-title {
            font-size: 14px;
            font-weight: 500;
            color: #2c2c2c;
            margin-bottom: 12px;
        }
        .field-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        .field-detected {
            color: #2d7d2d;
        }
        .field-missing {
            color: #d93025;
        }
        @media (max-width: 768px) {
            .timer-container {
                padding: 32px 24px;
            }
            .timer-display {
                font-size: 3.5rem;
            }
            .config-panel {
                width: 100%;
                right: -100%;
            }
        }
    </style>
</head>
<body>
    <button class="config-toggle" onclick="toggleConfig()">⚙️</button>
    
    <div class="timer-container">
        <div class="session-type" id="sessionType">FOCUS SESSION</div>
        <div class="timer-display" id="timerDisplay">25:00</div>
        <div class="progress-container">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div class="input-section">
            <div class="input-group">
                <label class="input-label">Focus Template</label>
                <select id="templateSelect" onchange="selectTemplate()">
                    <option value="standard">Standard • 25 min focus</option>
                    <option value="deep">Deep Work • 50 min focus</option>
                    <option value="quick">Quick Tasks • 15 min focus</option>
                    <option value="extended">Extended • 90 min focus</option>
                </select>
                <div id="templateDescription" class="template-description"></div>
            </div>

            <div class="input-group">
                <label class="input-label">Current Task</label>
                <input type="text" id="taskInput" placeholder="What are you focusing on?">
            </div>

            <div class="input-group">
                <label class="input-label">Target Database</label>
                <select id="databaseSelect" disabled>
                    <option value="">Connect to Notion first...</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="startBtn" onclick="startTimer()">Start Focus</button>
            <button class="btn btn-secondary" id="pauseBtn" onclick="pauseTimer()" disabled>Pause</button>
            <button class="btn btn-secondary" id="stopBtn" onclick="stopSession()" disabled>Stop</button>
        </div>

        <div id="sessionInfo" class="session-info hidden">
            <div class="session-detail">
                <span class="session-detail-label">Session Started</span>
                <span class="session-detail-value" id="sessionStart">--:--</span>
            </div>
            <div class="session-detail">
                <span class="session-detail-label">Template</span>
                <span class="session-detail-value" id="sessionTemplate">--</span>
            </div>
            <div class="session-detail">
                <span class="session-detail-label">Elapsed Time</span>
                <span class="session-detail-value" id="sessionElapsed">0 min</span>
            </div>
            <div class="session-detail">
                <span class="session-detail-label">Interruptions</span>
                <span class="session-detail-value" id="sessionInterruptions">0</span>
            </div>
        </div>
    </div>

    <div id="configPanel" class="config-panel">
        <div class="config-header">
            <h2 class="config-title">Configuration</h2>
            <button class="close-config" onclick="toggleConfig()">×</button>
        </div>

        <div class="input-group">
            <label class="input-label">Notion Integration Token</label>
            <input type="password" id="notionToken" placeholder="secret_...">
        </div>

        <div class="input-group">
    <label class="input-label">Notion Page ID</label>
    <input type="text" id="notionPageId" placeholder="Page ID from Notion URL">
</div>

        <div class="input-group">
            <label class="input-label">N8N Webhook URL</label>
            <input type="url" id="webhookUrl" placeholder="https://your-n8n-instance.com/webhook/timer">
        </div>

        <button class="btn btn-primary" onclick="testConnection()" style="width: 100%; margin: 16px 0;">
            Connect & Detect Fields
        </button>

        <div id="connectionStatus" class="connection-status status-disconnected">
            ⚠️ Not Connected
        </div>

        <div id="fieldMapping" class="field-mapping hidden">
            <div class="field-mapping-title">Database Field Detection</div>
            <div class="field-row">
                <span>Title/Name Field:</span>
                <span id="titleField" class="field-missing">Not detected</span>
            </div>
            <div class="field-row">
                <span>Duration Field:</span>
                <span id="durationField" class="field-missing">Not detected</span>
            </div>
            <div class="field-row">
                <span>Status Field:</span>
                <span id="statusField" class="field-missing">Not detected</span>
            </div>
            <div class="field-row">
                <span>Date Field:</span>
                <span id="dateField" class="field-missing">Not detected</span>
            </div>
            <div class="field-row">
                <span>Template Field:</span>
                <span id="templateField" class="field-missing">Not detected</span>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        // Timer management functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            const display = document.getElementById('timerDisplay');
            const progressFill = document.getElementById('progressFill');
            const sessionType = document.getElementById('sessionType');
            
            display.textContent = formatTime(timerState.currentTime);
            
            // Update progress bar
            const progress = ((timerState.originalTime - timerState.currentTime) / timerState.originalTime) * 100;
            progressFill.style.width = `${Math.max(0, Math.min(100, progress))}%`;
            
            // Update session type display
            if (timerState.isBreakSession) {
                sessionType.textContent = timerState.breakType === 'long' ? 'LONG BREAK' : 'SHORT BREAK';
                sessionType.style.color = '#2d7d2d';
            } else {
                sessionType.textContent = 'FOCUS SESSION';
                sessionType.style.color = '#6b6b6b';
            }
            
            // Add pulse effect when timer is low
            if (timerState.currentTime <= 60 && timerState.isRunning) {
                display.classList.add('pulse');
            } else {
                display.classList.remove('pulse');
            }
        }

        function selectTemplate() {
            const select = document.getElementById('templateSelect');
            const description = document.getElementById('templateDescription');
            const template = templates[select.value];
            
            timerState.currentTemplate = select.value;
            description.textContent = template.description;
            
            // Update timer if not running
            if (!timerState.isRunning) {
                timerState.currentTime = template.focus;
                timerState.originalTime = template.focus;
                timerState.isBreakSession = false;
                updateTimerDisplay();
            }
        }

        function startTimer() {
            const taskInput = document.getElementById('taskInput');
            const task = taskInput.value.trim();
            
            if (!task) {
                showNotification('Please enter a task to focus on', 'error');
                taskInput.focus();
                return;
            }
            
            if (!timerState.isPaused) {
                // Starting new session
                timerState.currentTask = task;
                timerState.sessionId = Date.now().toString();
                timerState.startTime = new Date();
                timerState.interruptions = [];
                timerState.totalPauses = 0;
                
                // Send session start to webhook
                sendSessionData('start');
            }
            
            timerState.isRunning = true;
            timerState.isPaused = false;
            timerState.lastUpdateTime = Date.now();
            
            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('sessionInfo').classList.remove('hidden');
            
            updateSessionInfo();
            
            // Start the timer interval
            timerInterval = setInterval(() => {
                if (timerState.currentTime > 0) {
                    timerState.currentTime--;
                    updateTimerDisplay();
                    updateSessionInfo();
                } else {
                    completeSession();
                }
            }, 1000);
            
            showNotification('Focus session started!', 'success');
        }

        function pauseTimer() {
            if (!timerState.isRunning) return;
            
            timerState.isRunning = false;
            timerState.isPaused = true;
            timerState.totalPauses++;
            
            // Record interruption
            timerState.interruptions.push({
                timestamp: new Date(),
                type: 'manual_pause',
                duration: Date.now() - timerState.lastUpdateTime
            });
            
            clearInterval(timerInterval);
            
            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('startBtn').textContent = 'Resume';
            
            updateSessionInfo();
            showNotification('Session paused', 'info');
        }

        function stopSession() {
            if (!timerState.isRunning && !timerState.isPaused) return;
            
            const wasRunning = timerState.isRunning;
            
            timerState.isRunning = false;
            timerState.isPaused = false;
            clearInterval(timerInterval);
            
            // Send session data before reset
            if (timerState.sessionId) {
                sendSessionData('stop');
            }
            
            // Reset timer state
            const template = templates[timerState.currentTemplate];
            timerState.currentTime = template.focus;
            timerState.originalTime = template.focus;
            timerState.sessionId = null;
            timerState.currentTask = null;
            timerState.startTime = null;
            timerState.interruptions = [];
            timerState.totalPauses = 0;
            timerState.isBreakSession = false;
            
            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('startBtn').textContent = 'Start Focus';
            document.getElementById('sessionInfo').classList.add('hidden');
            document.getElementById('taskInput').value = '';
            
            updateTimerDisplay();
            
            if (wasRunning) {
                showNotification('Session stopped', 'info');
            }
        }

        function completeSession() {
            clearInterval(timerInterval);
            
            // Send completion data
            sendSessionData('complete');
            
            // Update session count
            timerState.sessionCount++;
            timerState.completedInRow++;
            
            // Play notification sound (if browser supports it)
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYgBzuL0u/JgiEFJG/E8OSQQwoUW6/n06NZFApBl+LtrGQYBSeL0ezPfSEGJXPH7Nqdrgop');
                audio.play();
            } catch (e) {
                // Silent fail for audio
            }
            
            // Show completion notification
            const sessionMinutes = Math.ceil((timerState.originalTime - timerState.currentTime) / 60);
            showNotification(`🎉 Focus session completed! (${sessionMinutes} min)`, 'success');
            
            // Determine next session type
            const template = templates[timerState.currentTemplate];
            const shouldTakeLongBreak = timerState.completedInRow % template.sessionsUntilLongBreak === 0;
            
            // Auto-start break if configured
            setTimeout(() => {
                startBreakSession(shouldTakeLongBreak ? 'long' : 'short');
            }, 2000);
        }

        function startBreakSession(breakType) {
            const template = templates[timerState.currentTemplate];
            const breakDuration = breakType === 'long' ? template.longBreak : template.shortBreak;
            
            timerState.currentTime = breakDuration;
            timerState.originalTime = breakDuration;
            timerState.isBreakSession = true;
            timerState.breakType = breakType;
            timerState.sessionId = Date.now().toString();
            timerState.startTime = new Date();
            
            updateTimerDisplay();
            
            // Auto-start break timer
            timerState.isRunning = true;
            timerState.isPaused = false;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('stopBtn').disabled = false;
            
            timerInterval = setInterval(() => {
                if (timerState.currentTime > 0) {
                    timerState.currentTime--;
                    updateTimerDisplay();
                } else {
                    completeBreakSession();
                }
            }, 1000);
            
            const breakTypeName = breakType === 'long' ? 'long break' : 'short break';
            showNotification(`Starting ${breakTypeName} (${Math.ceil(breakDuration / 60)} min)`, 'info');
        }

        function completeBreakSession() {
            clearInterval(timerInterval);
            
            // Send break completion data
            sendSessionData('break_complete');
            
            // Reset to focus session
            const template = templates[timerState.currentTemplate];
            timerState.currentTime = template.focus;
            timerState.originalTime = template.focus;
            timerState.isBreakSession = false;
            timerState.isRunning = false;
            timerState.isPaused = false;
            timerState.sessionId = null;
            
            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('startBtn').textContent = 'Start Focus';
            document.getElementById('sessionInfo').classList.add('hidden');
            
            updateTimerDisplay();
            showNotification('Break completed! Ready for next focus session', 'success');
        }

        function updateSessionInfo() {
            if (!timerState.sessionId) return;
            
            const startTimeEl = document.getElementById('sessionStart');
            const templateEl = document.getElementById('sessionTemplate');
            const elapsedEl = document.getElementById('sessionElapsed');
            const interruptionsEl = document.getElementById('sessionInterruptions');
            
            if (timerState.startTime) {
                startTimeEl.textContent = timerState.startTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
            }
            
            templateEl.textContent = templates[timerState.currentTemplate].name;
            
            const elapsedSeconds = timerState.originalTime - timerState.currentTime;
            const elapsedMinutes = Math.floor(elapsedSeconds / 60);
            elapsedEl.textContent = `${elapsedMinutes} min`;
            
            interruptionsEl.textContent = timerState.totalPauses.toString();
        }
        // Notion and N8N Integration
async function testConnection() {
    const token = document.getElementById('notionToken').value.trim();
    const pageId = document.getElementById('notionPageId').value.trim();
    const webhookUrl = document.getElementById('webhookUrl').value.trim();
    
    if (!token || !pageId || !webhookUrl) {
        showNotification('Please enter Notion token, page ID, and webhook URL', 'error');
        return;
    }
    
    updateConnectionStatus('connecting');
    
    try {
        // Test webhook connection first
        const webhookResponse = await fetch(webhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                type: 'connection_test',
                timestamp: new Date().toISOString()
            })
        });
        
        if (!webhookResponse.ok) {
            throw new Error('Webhook connection failed');
        }
        
        // Fetch databases from the specific page
        const notionResponse = await fetch(`https://api.notion.com/v1/blocks/${pageId}/children`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
            }
        });
        
        if (!notionResponse.ok) {
            throw new Error(`Notion API error: ${notionResponse.status}`);
        }
        
        const data = await notionResponse.json();
        
        // Filter for database blocks
        const databases = data.results.filter(block => 
            block.type === 'child_database' && block.child_database
        );
        
        if (databases.length === 0) {
            throw new Error('No databases found in this page');
        }
        
        // Get full database info for each database
        const databasePromises = databases.map(async (db) => {
            const dbResponse = await fetch(`https://api.notion.com/v1/databases/${db.id}`, {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Notion-Version': '2022-06-28'
                }
            });
            
            if (dbResponse.ok) {
                return await dbResponse.json();
            }
            return null;
        });
        
        const fullDatabases = await Promise.all(databasePromises);
        config.databases = fullDatabases.filter(db => db !== null);
        config.notionToken = token;
        config.webhookUrl = webhookUrl;
        config.notionPageId = pageId;
        
        populateDatabaseSelect();
        updateConnectionStatus('connected');
        showNotification(`Successfully connected! Found ${config.databases.length} databases`, 'success');
        
    } catch (error) {
        console.error('Connection test failed:', error);
        updateConnectionStatus('disconnected');
        showNotification('Connection failed: ' + error.message, 'error');
    }
}
        
        function populateDatabaseSelect() {
            const select = document.getElementById('databaseSelect');
            select.innerHTML = '<option value="">Select a database...</option>';
            
            config.databases.forEach(db => {
                const option = document.createElement('option');
                option.value = db.id;
                option.textContent = db.title[0]?.plain_text || 'Untitled Database';
                select.appendChild(option);
            });
            
            select.disabled = false;
            select.addEventListener('change', analyzeDatabaseFields);
        }
        
        async function analyzeDatabaseFields() {
            const select = document.getElementById('databaseSelect');
            const databaseId = select.value;
            
            if (!databaseId) return;
            
            try {
                const response = await fetch(`https://api.notion.com/v1/databases/${databaseId}`, {
                    headers: {
                        'Authorization': `Bearer ${config.notionToken}`,
                        'Notion-Version': '2022-06-28'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch database properties');
                }
                
                const database = await response.json();
                const properties = database.properties;
                
                // Auto-detect field mappings
                config.databaseFields = {
                    title: findFieldByType(properties, 'title') || findFieldByName(properties, ['name', 'task', 'title']),
                    duration: findFieldByName(properties, ['duration', 'time', 'minutes', 'length']),
                    status: findFieldByType(properties, 'select') || findFieldByName(properties, ['status', 'state', 'progress']),
                    date: findFieldByType(properties, 'date') || findFieldByName(properties, ['date', 'created', 'start']),
                    template: findFieldByName(properties, ['template', 'type', 'category', 'method']),
                    sessionType: findFieldByName(properties, ['session', 'session_type', 'mode']),
                    interruptions: findFieldByName(properties, ['interruptions', 'pauses', 'breaks']),
                    efficiency: findFieldByName(properties, ['efficiency', 'score', 'performance'])
                };
                
                config.selectedDatabase = databaseId;
                updateFieldMappingDisplay();
                showNotification('Database fields analyzed successfully', 'success');
                
            } catch (error) {
                console.error('Database analysis failed:', error);
                showNotification('Failed to analyze database: ' + error.message, 'error');
            }
        }
        
        function findFieldByType(properties, type) {
            for (const [name, prop] of Object.entries(properties)) {
                if (prop.type === type) {
                    return name;
                }
            }
            return null;
        }
        
        function findFieldByName(properties, keywords) {
            const propNames = Object.keys(properties).map(name => name.toLowerCase());
            
            for (const keyword of keywords) {
                const match = propNames.find(name => 
                    name.includes(keyword.toLowerCase()) || 
                    keyword.toLowerCase().includes(name)
                );
                if (match) {
                    return Object.keys(properties).find(name => name.toLowerCase() === match);
                }
            }
            return null;
        }
        
        function updateFieldMappingDisplay() {
            const mapping = document.getElementById('fieldMapping');
            mapping.classList.remove('hidden');
            
            const fields = [
                { id: 'titleField', key: 'title', label: 'Title/Name Field' },
                { id: 'durationField', key: 'duration', label: 'Duration Field' },
                { id: 'statusField', key: 'status', label: 'Status Field' },
                { id: 'dateField', key: 'date', label: 'Date Field' },
                { id: 'templateField', key: 'template', label: 'Template Field' }
            ];
            
            fields.forEach(field => {
                const element = document.getElementById(field.id);
                const fieldName = config.databaseFields[field.key];
                
                if (fieldName) {
                    element.textContent = fieldName;
                    element.className = 'field-detected';
                } else {
                    element.textContent = 'Not detected';
                    element.className = 'field-missing';
                }
            });
        }
        
        async function sendSessionData(eventType) {
            if (!config.webhookUrl || !config.selectedDatabase) return;
            
            const sessionData = {
                type: eventType,
                sessionId: timerState.sessionId,
                timestamp: new Date().toISOString(),
                task: timerState.currentTask,
                template: timerState.currentTemplate,
                templateName: templates[timerState.currentTemplate].name,
                databaseId: config.selectedDatabase,
                fieldMappings: config.databaseFields,
                sessionData: {
                    startTime: timerState.startTime?.toISOString(),
                    duration: eventType === 'complete' ? timerState.originalTime : 
                             (timerState.originalTime - timerState.currentTime),
                    remainingTime: timerState.currentTime,
                    interruptions: timerState.interruptions.length,
                    totalPauses: timerState.totalPauses,
                    isBreakSession: timerState.isBreakSession,
                    breakType: timerState.breakType,
                    sessionCount: timerState.sessionCount,
                    completedInRow: timerState.completedInRow
                },
                performance: calculatePerformanceMetrics()
            };
            
            try {
                const response = await fetch(config.webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(sessionData)
                });
                
                if (!response.ok) {
                    throw new Error(`Webhook request failed: ${response.status}`);
                }
                
                console.log('Session data sent successfully:', eventType);
                
            } catch (error) {
                console.error('Failed to send session data:', error);
                // Don't show notification for webhook failures to avoid interrupting focus
            }
        }
        
        function calculatePerformanceMetrics() {
            const totalElapsed = timerState.originalTime - timerState.currentTime;
            const efficiency = totalElapsed > 0 ? 
                ((totalElapsed - (timerState.interruptions.length * 30)) / totalElapsed) * 100 : 0;
            
            return {
                efficiency: Math.max(0, Math.min(100, efficiency)),
                focusTime: totalElapsed,
                interruptionRate: totalElapsed > 0 ? (timerState.interruptions.length / (totalElapsed / 60)) : 0,
                completionRate: timerState.currentTime === 0 ? 100 : 
                    ((timerState.originalTime - timerState.currentTime) / timerState.originalTime) * 100
            };
        }
        
        // UI Helper Functions
        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            config.connectionStatus = status;
            
            statusEl.classList.remove('status-connected', 'status-disconnected', 'status-connecting');
            
            switch (status) {
                case 'connected':
                    statusEl.classList.add('status-connected');
                    statusEl.innerHTML = '✅ Connected';
                    break;
                case 'connecting':
                    statusEl.classList.add('status-connecting');
                    statusEl.innerHTML = '🔄 Connecting...';
                    break;
                default:
                    statusEl.classList.add('status-disconnected');
                    statusEl.innerHTML = '⚠️ Not Connected';
            }
        }
        
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }
        
        function toggleConfig() {
            const panel = document.getElementById('configPanel');
            panel.classList.toggle('open');
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Space bar to start/pause (when not typing in inputs)
            if (e.code === 'Space' && !e.target.matches('input, textarea, select')) {
                e.preventDefault();
                if (timerState.isRunning) {
                    pauseTimer();
                } else if (timerState.isPaused) {
                    startTimer();
                } else {
                    // Only start if task is entered
                    const taskInput = document.getElementById('taskInput');
                    if (taskInput.value.trim()) {
                        startTimer();
                    } else {
                        taskInput.focus();
                    }
                }
            }
            
            // Escape to stop session
            if (e.code === 'Escape' && (timerState.isRunning || timerState.isPaused)) {
                e.preventDefault();
                stopSession();
            }
            
            // Ctrl/Cmd + / to toggle config
            if ((e.ctrlKey || e.metaKey) && e.code === 'Slash') {
                e.preventDefault();
                toggleConfig();
            }
        });
        
        // Page visibility handling - pause timer when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && timerState.isRunning && !timerState.isBreakSession) {
                // Add interruption for tab switching during focus
                timerState.interruptions.push({
                    timestamp: new Date(),
                    type: 'tab_hidden',
                    duration: 0
                });
                updateSessionInfo();
            }
        });
        
        // Initialize application
        function initializeApp() {
            // Set default template description
            selectTemplate();
            
            // Focus on task input
            document.getElementById('taskInput').focus();
            
            // Add Enter key support for task input
            document.getElementById('taskInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !timerState.isRunning && !timerState.isPaused) {
                    startTimer();
                }
            });
            
            // Prevent form submission
            document.addEventListener('submit', (e) => {
                e.preventDefault();
            });
            
            console.log('Focus Timer initialized');
        }
        
        // Start the app when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
        
    </script>
</body>
</html>
